// Generated by the Table Description Language compiler.  DO NOT EDIT!
// source: EquipAttData.prot

#ifndef _TDL_EQUIPATTDATA_H_
#define _TDL_EQUIPATTDATA_H_

#include "table_utility.h"

class EquipAttData;
class EquipAttDataManager;


// ===================================================================
#pragma pack( 1 )
class EquipAttData
{
public:
	// nested types ----------------------------------------------------
	typedef Table::RepeatField< EquipAttDataManager, uint8 >	GemGroupID;
	
	// -------------------------------------------------------------------
	class StrAddAtt
	{
	public:
		uint8 id() const;
		uint16 value() const;
		
	private:
		uint8  m_id;
		uint16 m_value;
	};
	
	// -------------------------------------------------------------------
	typedef Table::RepeatField< EquipAttDataManager, StrAddAtt >	StrAddAttID;
	
	typedef uint32	KeyType;
	
	static const uint32 Version = 2817411046;
	
	uint32 Key() const;
	
	uint32 id() const;
	const char* name() const;
	uint8 wearparts() const;
	uint32 modelid() const;
	uint8 quality() const;
	uint8 wearlevel() const;
	const char* wearrank() const;
	uint8 wearjob() const;
	uint8 lvlimit() const;
	uint8 canbind() const;
	uint8 equiptime() const;
	const StrAddAttID& addid() const;
	uint32 life() const;
	uint32 attack() const;
	uint32 defend() const;
	uint32 hit() const;
	uint32 dodge() const;
	uint32 crit() const;
	uint32 toughness() const;
	uint8 holesnum() const;
	
private:
	uint32      m_id;
	int         m_name;
	uint8       m_wearParts;
	uint32      m_modelID;
	uint8       m_quality;
	uint8       m_wearLevel;
	int         m_wearRank;
	uint8       m_wearJob;
	uint8       m_lvLimit;
	uint8       m_canBind;
	uint8       m_equipTime;
	StrAddAttID m_addID;
	uint32      m_life;
	uint32      m_attack;
	uint32      m_defend;
	uint32      m_hit;
	uint32      m_dodge;
	uint32      m_crit;
	uint32      m_toughness;
	uint8       m_holesNum;
};
#pragma pack()

// -------------------------------------------------------------------
// source: Z 装备基础属性表.xls, sheet: Sheet1
class EquipAttDataManager : public Table::Manager, public Singleton< EquipAttDataManager >
{
public:
	int Size() const;
	const char* Source() const;
	bool Load( const char *path );
	bool Reload( const char *path );
	
	const EquipAttData& Get( int index ) const;
	const EquipAttData* Find( const uint32 key ) const;
	
private:
	friend class Singleton< EquipAttDataManager >;
	typedef Table::RepeatField< EquipAttDataManager, EquipAttData >	EquipAttDataArray;
	
	EquipAttDataManager();
	~EquipAttDataManager();
	
private:
	const EquipAttDataArray *m_array;
};


// ===================================================================
// inline methords of EquipAttData
inline uint32 EquipAttData::Key() const
{
	return Combiner< uint32 >::Combine( m_id );
}

inline uint32 EquipAttData::id() const
{
	return m_id;
}

inline const char* EquipAttData::name() const
{
	return EquipAttDataManager::Instance().String( m_name );
}

inline uint8 EquipAttData::wearparts() const
{
	return m_wearParts;
}

inline uint32 EquipAttData::modelid() const
{
	return m_modelID;
}

inline uint8 EquipAttData::quality() const
{
	return m_quality;
}

inline uint8 EquipAttData::wearlevel() const
{
	return m_wearLevel;
}

inline const char* EquipAttData::wearrank() const
{
	return EquipAttDataManager::Instance().String( m_wearRank );
}

inline uint8 EquipAttData::wearjob() const
{
	return m_wearJob;
}

inline uint8 EquipAttData::lvlimit() const
{
	return m_lvLimit;
}

inline uint8 EquipAttData::canbind() const
{
	return m_canBind;
}

inline uint8 EquipAttData::equiptime() const
{
	return m_equipTime;
}

inline const EquipAttData::StrAddAttID& EquipAttData::addid() const
{
	return m_addID;
}

inline uint32 EquipAttData::life() const
{
	return m_life;
}

inline uint32 EquipAttData::attack() const
{
	return m_attack;
}

inline uint32 EquipAttData::defend() const
{
	return m_defend;
}

inline uint32 EquipAttData::hit() const
{
	return m_hit;
}

inline uint32 EquipAttData::dodge() const
{
	return m_dodge;
}

inline uint32 EquipAttData::crit() const
{
	return m_crit;
}

inline uint32 EquipAttData::toughness() const
{
	return m_toughness;
}

inline uint8 EquipAttData::holesnum() const
{
	return m_holesNum;
}


// inline methords of EquipAttData::StrAddAtt
inline uint8 EquipAttData::StrAddAtt::id() const
{
	return m_id;
}

inline uint16 EquipAttData::StrAddAtt::value() const
{
	return m_value;
}


// inline methords of EquipAttDataManager
inline EquipAttDataManager::EquipAttDataManager()
	: m_array( NULL )
{
}

inline EquipAttDataManager::~EquipAttDataManager()
{
}

inline int EquipAttDataManager::Size() const
{
	assert( m_array );
	return m_array->Size();
}

inline const char* EquipAttDataManager::Source() const
{
	return "equipattdata.tbl";
}

inline bool EquipAttDataManager::Load( const char *path )
{
	const char *data = Table::Manager::Load( path, Source() );
	if( !data )
		return false;
		
	m_array = (const EquipAttDataArray *)data;
	return true;
}

inline bool EquipAttDataManager::Reload( const char *path )
{
	const char *data = Table::Manager::Reload( path, Source() );
	if( !data )
		return false;
		
	m_array = (const EquipAttDataArray *)data;
	return true;
}

inline const EquipAttData& EquipAttDataManager::Get( int index ) const
{
	assert( m_array );
	return m_array->Get( index );
}

inline const EquipAttData* EquipAttDataManager::Find( uint32 key ) const
{
	assert( m_array );
	return BinarySerach< EquipAttData >( Data( m_array->Offset() ), m_array->Size(), key );
}


#endif
