// Generated by the Table Description Language compiler.  DO NOT EDIT!
// source: ItemData.prot

#ifndef _TDL_ITEMDATA_H_
#define _TDL_ITEMDATA_H_

#include "table_utility.h"

class ItemData;
class ItemDataManager;


// ===================================================================
#pragma pack( 1 )
class ItemData
{
public:
	// nested types ----------------------------------------------------
	typedef uint32	KeyType;
	
	static const uint32 Version = 74161443;
	
	uint32 Key() const;
	
	uint32 id() const;
	const char* name() const;
	const char* icon() const;
	const char* model() const;
	uint8 type() const;
	uint8 quality() const;
	uint8 canbind() const;
	uint8 useeffect1() const;
	const char* useeffectarg1() const;
	
private:
	uint32 m_id;
	int    m_name;
	int    m_icon;
	int    m_model;
	uint8  m_type;
	uint8  m_quality;
	uint8  m_canBind;
	uint8  m_useEffect1;
	int    m_useEffectArg1;
};
#pragma pack()

// -------------------------------------------------------------------
// source: D 道具配置.xls, sheet: Sheet1
class ItemDataManager : public Table::Manager, public Singleton< ItemDataManager >
{
public:
	int Size() const;
	const char* Source() const;
	bool Load( const char *path );
	bool Reload( const char *path );
	
	const ItemData& Get( int index ) const;
	const ItemData* Find( const uint32 key ) const;
	
private:
	friend class Singleton< ItemDataManager >;
	typedef Table::RepeatField< ItemDataManager, ItemData >	ItemDataArray;
	
	ItemDataManager();
	~ItemDataManager();
	
private:
	const ItemDataArray *m_array;
};


// ===================================================================
// inline methords of ItemData
inline uint32 ItemData::Key() const
{
	return Combiner< uint32 >::Combine( m_id );
}

inline uint32 ItemData::id() const
{
	return m_id;
}

inline const char* ItemData::name() const
{
	return ItemDataManager::Instance().String( m_name );
}

inline const char* ItemData::icon() const
{
	return ItemDataManager::Instance().String( m_icon );
}

inline const char* ItemData::model() const
{
	return ItemDataManager::Instance().String( m_model );
}

inline uint8 ItemData::type() const
{
	return m_type;
}

inline uint8 ItemData::quality() const
{
	return m_quality;
}

inline uint8 ItemData::canbind() const
{
	return m_canBind;
}

inline uint8 ItemData::useeffect1() const
{
	return m_useEffect1;
}

inline const char* ItemData::useeffectarg1() const
{
	return ItemDataManager::Instance().String( m_useEffectArg1 );
}


// inline methords of ItemDataManager
inline ItemDataManager::ItemDataManager()
	: m_array( NULL )
{
}

inline ItemDataManager::~ItemDataManager()
{
}

inline int ItemDataManager::Size() const
{
	assert( m_array );
	return m_array->Size();
}

inline const char* ItemDataManager::Source() const
{
	return "itemdata.tbl";
}

inline bool ItemDataManager::Load( const char *path )
{
	const char *data = Table::Manager::Load( path, Source() );
	if( !data )
		return false;
		
	m_array = (const ItemDataArray *)data;
	return true;
}

inline bool ItemDataManager::Reload( const char *path )
{
	const char *data = Table::Manager::Reload( path, Source() );
	if( !data )
		return false;
		
	m_array = (const ItemDataArray *)data;
	return true;
}

inline const ItemData& ItemDataManager::Get( int index ) const
{
	assert( m_array );
	return m_array->Get( index );
}

inline const ItemData* ItemDataManager::Find( uint32 key ) const
{
	assert( m_array );
	return BinarySerach< ItemData >( Data( m_array->Offset() ), m_array->Size(), key );
}


#endif
