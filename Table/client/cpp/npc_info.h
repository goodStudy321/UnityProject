// Generated by the Table Description Language compiler.  DO NOT EDIT!
// source: npc_info.prot

#ifndef _TDL_NPC_INFO_H_
#define _TDL_NPC_INFO_H_

#include "table_utility.h"

class NPCInfo;
class NPCInfoManager;


// ===================================================================
#pragma pack( 1 )
class NPCInfo
{
public:
	// nested types ----------------------------------------------------
	class vector3
	{
	public:
		int32 x() const;
		int32 y() const;
		int32 z() const;
		
	private:
		int32 m_x;
		int32 m_y;
		int32 m_z;
	};
	
	// -------------------------------------------------------------------
	class data
	{
	public:
		uint8 type() const;
		const char* btn_des() const;
		uint32 id() const;
		
	private:
		uint8  m_type;
		int    m_btn_des;
		uint32 m_id;
	};
	
	// -------------------------------------------------------------------
	class hide
	{
	public:
		uint32 scene_id() const;
		uint32 mission_id() const;
		
	private:
		uint32 m_scene_id;
		uint32 m_mission_id;
	};
	
	// -------------------------------------------------------------------
	typedef Table::RepeatField< NPCInfoManager, hide >	hideList;
	
	typedef uint32	KeyType;
	
	static const uint32 Version = 1768006109;
	
	uint32 Key() const;
	
	uint32 id() const;
	uint16 mode_id() const;
	uint16 ui_mode_id() const;
	const char* name() const;
	const char* head_pic_path() const;
	const char* title() const;
	uint8 type() const;
	uint32 map_id() const;
	const vector3& pos() const;
	uint16 rot() const;
	uint16 scal() const;
	uint8 camp() const;
	uint8 interactive() const;
	const data& interactive_data() const;
	const char* interactive_talk() const;
	const char* audio() const;
	const hideList& h_list() const;
	const hideList& s_list() const;
	const char* pose() const;
	uint8 rotation() const;
	
private:
	uint32   m_id;
	uint16   m_mode_id;
	uint16   m_ui_mode_id;
	int      m_name;
	int      m_head_pic_path;
	int      m_title;
	uint8    m_type;
	uint32   m_map_id;
	vector3  m_pos;
	uint16   m_rot;
	uint16   m_scal;
	uint8    m_camp;
	uint8    m_interactive;
	data     m_interactive_data;
	int      m_interactive_talk;
	int      m_audio;
	hideList m_h_list;
	hideList m_s_list;
	int      m_pose;
	uint8    m_rotation;
};
#pragma pack()

// -------------------------------------------------------------------
// source: N NPC配置表.xls, sheet: Sheet1
class NPCInfoManager : public Table::Manager, public Singleton< NPCInfoManager >
{
public:
	int Size() const;
	const char* Source() const;
	bool Load( const char *path );
	bool Reload( const char *path );
	
	const NPCInfo& Get( int index ) const;
	const NPCInfo* Find( const uint32 key ) const;
	
private:
	friend class Singleton< NPCInfoManager >;
	typedef Table::RepeatField< NPCInfoManager, NPCInfo >	NPCInfoArray;
	
	NPCInfoManager();
	~NPCInfoManager();
	
private:
	const NPCInfoArray *m_array;
};


// ===================================================================
// inline methords of NPCInfo
inline uint32 NPCInfo::Key() const
{
	return Combiner< uint32 >::Combine( m_id );
}

inline uint32 NPCInfo::id() const
{
	return m_id;
}

inline uint16 NPCInfo::mode_id() const
{
	return m_mode_id;
}

inline uint16 NPCInfo::ui_mode_id() const
{
	return m_ui_mode_id;
}

inline const char* NPCInfo::name() const
{
	return NPCInfoManager::Instance().String( m_name );
}

inline const char* NPCInfo::head_pic_path() const
{
	return NPCInfoManager::Instance().String( m_head_pic_path );
}

inline const char* NPCInfo::title() const
{
	return NPCInfoManager::Instance().String( m_title );
}

inline uint8 NPCInfo::type() const
{
	return m_type;
}

inline uint32 NPCInfo::map_id() const
{
	return m_map_id;
}

inline const NPCInfo::vector3& NPCInfo::pos() const
{
	return m_pos;
}

inline uint16 NPCInfo::rot() const
{
	return m_rot;
}

inline uint16 NPCInfo::scal() const
{
	return m_scal;
}

inline uint8 NPCInfo::camp() const
{
	return m_camp;
}

inline uint8 NPCInfo::interactive() const
{
	return m_interactive;
}

inline const NPCInfo::data& NPCInfo::interactive_data() const
{
	return m_interactive_data;
}

inline const char* NPCInfo::interactive_talk() const
{
	return NPCInfoManager::Instance().String( m_interactive_talk );
}

inline const char* NPCInfo::audio() const
{
	return NPCInfoManager::Instance().String( m_audio );
}

inline const NPCInfo::hideList& NPCInfo::h_list() const
{
	return m_h_list;
}

inline const NPCInfo::hideList& NPCInfo::s_list() const
{
	return m_s_list;
}

inline const char* NPCInfo::pose() const
{
	return NPCInfoManager::Instance().String( m_pose );
}

inline uint8 NPCInfo::rotation() const
{
	return m_rotation;
}


// inline methords of NPCInfo::vector3
inline int32 NPCInfo::vector3::x() const
{
	return m_x;
}

inline int32 NPCInfo::vector3::y() const
{
	return m_y;
}

inline int32 NPCInfo::vector3::z() const
{
	return m_z;
}


// inline methords of NPCInfo::data
inline uint8 NPCInfo::data::type() const
{
	return m_type;
}

inline const char* NPCInfo::data::btn_des() const
{
	return NPCInfoManager::Instance().String( m_btn_des );
}

inline uint32 NPCInfo::data::id() const
{
	return m_id;
}


// inline methords of NPCInfo::hide
inline uint32 NPCInfo::hide::scene_id() const
{
	return m_scene_id;
}

inline uint32 NPCInfo::hide::mission_id() const
{
	return m_mission_id;
}


// inline methords of NPCInfoManager
inline NPCInfoManager::NPCInfoManager()
	: m_array( NULL )
{
}

inline NPCInfoManager::~NPCInfoManager()
{
}

inline int NPCInfoManager::Size() const
{
	assert( m_array );
	return m_array->Size();
}

inline const char* NPCInfoManager::Source() const
{
	return "npc_info.tbl";
}

inline bool NPCInfoManager::Load( const char *path )
{
	const char *data = Table::Manager::Load( path, Source() );
	if( !data )
		return false;
		
	m_array = (const NPCInfoArray *)data;
	return true;
}

inline bool NPCInfoManager::Reload( const char *path )
{
	const char *data = Table::Manager::Reload( path, Source() );
	if( !data )
		return false;
		
	m_array = (const NPCInfoArray *)data;
	return true;
}

inline const NPCInfo& NPCInfoManager::Get( int index ) const
{
	assert( m_array );
	return m_array->Get( index );
}

inline const NPCInfo* NPCInfoManager::Find( uint32 key ) const
{
	assert( m_array );
	return BinarySerach< NPCInfo >( Data( m_array->Offset() ), m_array->Size(), key );
}


#endif
