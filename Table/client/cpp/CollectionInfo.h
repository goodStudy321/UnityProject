// Generated by the Table Description Language compiler.  DO NOT EDIT!
// source: CollectionInfo.prot

#ifndef _TDL_COLLECTIONINFO_H_
#define _TDL_COLLECTIONINFO_H_

#include "table_utility.h"

class CollectionInfo;
class CollectionInfoManager;


// ===================================================================
#pragma pack( 1 )
class CollectionInfo
{
public:
	// nested types ----------------------------------------------------
	class CreateCond
	{
	public:
		uint8 type() const;
		int32 arg() const;
		
	private:
		uint8 m_type;
		int32 m_arg;
	};
	
	typedef uint32	KeyType;
	
	static const uint32 Version = 1941969618;
	
	uint32 Key() const;
	
	uint32 id() const;
	const char* name() const;
	const char* model() const;
	const char* bornani() const;
	const char* idleani() const;
	const char* runani() const;
	const char* dieani() const;
	uint8 trity() const;
	const char* triani() const;
	const char* floani() const;
	uint16 modelsize() const;
	uint16 distance() const;
	const char* icon() const;
	const char* text() const;
	uint8 removeonsuccess() const;
	const CreateCond& cond() const;
	int16 ht() const;
	
private:
	uint32     m_id;
	int        m_name;
	int        m_model;
	int        m_bornAni;
	int        m_idleAni;
	int        m_runAni;
	int        m_dieAni;
	uint8      m_TriTy;
	int        m_TriAni;
	int        m_FloAni;
	uint16     m_modelsize;
	uint16     m_distance;
	int        m_icon;
	int        m_text;
	uint8      m_removeOnSuccess;
	CreateCond m_cond;
	int16      m_ht;
};
#pragma pack()

// -------------------------------------------------------------------
// source: C 采集物配置.xls, sheet: Sheet1
class CollectionInfoManager : public Table::Manager, public Singleton< CollectionInfoManager >
{
public:
	int Size() const;
	const char* Source() const;
	bool Load( const char *path );
	bool Reload( const char *path );
	
	const CollectionInfo& Get( int index ) const;
	const CollectionInfo* Find( const uint32 key ) const;
	
private:
	friend class Singleton< CollectionInfoManager >;
	typedef Table::RepeatField< CollectionInfoManager, CollectionInfo >	CollectionInfoArray;
	
	CollectionInfoManager();
	~CollectionInfoManager();
	
private:
	const CollectionInfoArray *m_array;
};


// ===================================================================
// inline methords of CollectionInfo
inline uint32 CollectionInfo::Key() const
{
	return Combiner< uint32 >::Combine( m_id );
}

inline uint32 CollectionInfo::id() const
{
	return m_id;
}

inline const char* CollectionInfo::name() const
{
	return CollectionInfoManager::Instance().String( m_name );
}

inline const char* CollectionInfo::model() const
{
	return CollectionInfoManager::Instance().String( m_model );
}

inline const char* CollectionInfo::bornani() const
{
	return CollectionInfoManager::Instance().String( m_bornAni );
}

inline const char* CollectionInfo::idleani() const
{
	return CollectionInfoManager::Instance().String( m_idleAni );
}

inline const char* CollectionInfo::runani() const
{
	return CollectionInfoManager::Instance().String( m_runAni );
}

inline const char* CollectionInfo::dieani() const
{
	return CollectionInfoManager::Instance().String( m_dieAni );
}

inline uint8 CollectionInfo::trity() const
{
	return m_TriTy;
}

inline const char* CollectionInfo::triani() const
{
	return CollectionInfoManager::Instance().String( m_TriAni );
}

inline const char* CollectionInfo::floani() const
{
	return CollectionInfoManager::Instance().String( m_FloAni );
}

inline uint16 CollectionInfo::modelsize() const
{
	return m_modelsize;
}

inline uint16 CollectionInfo::distance() const
{
	return m_distance;
}

inline const char* CollectionInfo::icon() const
{
	return CollectionInfoManager::Instance().String( m_icon );
}

inline const char* CollectionInfo::text() const
{
	return CollectionInfoManager::Instance().String( m_text );
}

inline uint8 CollectionInfo::removeonsuccess() const
{
	return m_removeOnSuccess;
}

inline const CollectionInfo::CreateCond& CollectionInfo::cond() const
{
	return m_cond;
}

inline int16 CollectionInfo::ht() const
{
	return m_ht;
}


// inline methords of CollectionInfo::CreateCond
inline uint8 CollectionInfo::CreateCond::type() const
{
	return m_type;
}

inline int32 CollectionInfo::CreateCond::arg() const
{
	return m_arg;
}


// inline methords of CollectionInfoManager
inline CollectionInfoManager::CollectionInfoManager()
	: m_array( NULL )
{
}

inline CollectionInfoManager::~CollectionInfoManager()
{
}

inline int CollectionInfoManager::Size() const
{
	assert( m_array );
	return m_array->Size();
}

inline const char* CollectionInfoManager::Source() const
{
	return "collectioninfo.tbl";
}

inline bool CollectionInfoManager::Load( const char *path )
{
	const char *data = Table::Manager::Load( path, Source() );
	if( !data )
		return false;
		
	m_array = (const CollectionInfoArray *)data;
	return true;
}

inline bool CollectionInfoManager::Reload( const char *path )
{
	const char *data = Table::Manager::Reload( path, Source() );
	if( !data )
		return false;
		
	m_array = (const CollectionInfoArray *)data;
	return true;
}

inline const CollectionInfo& CollectionInfoManager::Get( int index ) const
{
	assert( m_array );
	return m_array->Get( index );
}

inline const CollectionInfo* CollectionInfoManager::Find( uint32 key ) const
{
	assert( m_array );
	return BinarySerach< CollectionInfo >( Data( m_array->Offset() ), m_array->Size(), key );
}


#endif
