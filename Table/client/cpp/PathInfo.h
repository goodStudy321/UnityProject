// Generated by the Table Description Language compiler.  DO NOT EDIT!
// source: PathInfo.prot

#ifndef _TDL_PATHINFO_H_
#define _TDL_PATHINFO_H_

#include "table_utility.h"

class PathInfo;
class PathInfoManager;


// ===================================================================
#pragma pack( 1 )
class PathInfo
{
public:
	// nested types ----------------------------------------------------
	class Vector3
	{
	public:
		int32 x() const;
		int32 y() const;
		int32 z() const;
		
	private:
		int32 m_x;
		int32 m_y;
		int32 m_z;
	};
	
	// -------------------------------------------------------------------
	class PointInfo
	{
	public:
		const Vector3& point() const;
		double duration() const;
		double delay() const;
		
	private:
		Vector3 m_point;
		double  m_duration;
		double  m_delay;
	};
	
	// -------------------------------------------------------------------
	typedef Table::RepeatField< PathInfoManager, PointInfo >	Points;
	
	typedef uint16	KeyType;
	
	static const uint32 Version = 2618868168;
	
	uint16 Key() const;
	
	uint16 id() const;
	const Points& points() const;
	uint8 defaultspeed() const;
	
private:
	uint16 m_id;
	Points m_points;
	uint8  m_DefaultSpeed;
};
#pragma pack()

// -------------------------------------------------------------------
// source: L 路径点.xls, sheet: Sheet1
class PathInfoManager : public Table::Manager, public Singleton< PathInfoManager >
{
public:
	int Size() const;
	const char* Source() const;
	bool Load( const char *path );
	bool Reload( const char *path );
	
	const PathInfo& Get( int index ) const;
	const PathInfo* Find( const uint16 key ) const;
	
private:
	friend class Singleton< PathInfoManager >;
	typedef Table::RepeatField< PathInfoManager, PathInfo >	PathInfoArray;
	
	PathInfoManager();
	~PathInfoManager();
	
private:
	const PathInfoArray *m_array;
};


// ===================================================================
// inline methords of PathInfo
inline uint16 PathInfo::Key() const
{
	return Combiner< uint16 >::Combine( m_id );
}

inline uint16 PathInfo::id() const
{
	return m_id;
}

inline const PathInfo::Points& PathInfo::points() const
{
	return m_points;
}

inline uint8 PathInfo::defaultspeed() const
{
	return m_DefaultSpeed;
}


// inline methords of PathInfo::Vector3
inline int32 PathInfo::Vector3::x() const
{
	return m_x;
}

inline int32 PathInfo::Vector3::y() const
{
	return m_y;
}

inline int32 PathInfo::Vector3::z() const
{
	return m_z;
}


// inline methords of PathInfo::PointInfo
inline const PathInfo::Vector3& PathInfo::PointInfo::point() const
{
	return m_point;
}

inline double PathInfo::PointInfo::duration() const
{
	return m_duration;
}

inline double PathInfo::PointInfo::delay() const
{
	return m_delay;
}


// inline methords of PathInfoManager
inline PathInfoManager::PathInfoManager()
	: m_array( NULL )
{
}

inline PathInfoManager::~PathInfoManager()
{
}

inline int PathInfoManager::Size() const
{
	assert( m_array );
	return m_array->Size();
}

inline const char* PathInfoManager::Source() const
{
	return "pathinfo.tbl";
}

inline bool PathInfoManager::Load( const char *path )
{
	const char *data = Table::Manager::Load( path, Source() );
	if( !data )
		return false;
		
	m_array = (const PathInfoArray *)data;
	return true;
}

inline bool PathInfoManager::Reload( const char *path )
{
	const char *data = Table::Manager::Reload( path, Source() );
	if( !data )
		return false;
		
	m_array = (const PathInfoArray *)data;
	return true;
}

inline const PathInfo& PathInfoManager::Get( int index ) const
{
	assert( m_array );
	return m_array->Get( index );
}

inline const PathInfo* PathInfoManager::Find( uint16 key ) const
{
	assert( m_array );
	return BinarySerach< PathInfo >( Data( m_array->Offset() ), m_array->Size(), key );
}


#endif
