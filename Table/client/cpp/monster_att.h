// Generated by the Table Description Language compiler.  DO NOT EDIT!
// source: monster_att.prot

#ifndef _TDL_MONSTER_ATT_H_
#define _TDL_MONSTER_ATT_H_

#include "table_utility.h"

class MonsterAtt;
class MonsterAttManager;


// ===================================================================
#pragma pack( 1 )
class MonsterAtt
{
public:
	// nested types ----------------------------------------------------
	typedef Table::RepeatField< MonsterAttManager, uint32 >	skillid;
	
	// -------------------------------------------------------------------
	class dropList
	{
	public:
		uint32 dropid() const;
		uint32 dropnum() const;
		
	private:
		uint32 m_dropid;
		uint32 m_dropNum;
	};
	
	// -------------------------------------------------------------------
	typedef Table::RepeatField< MonsterAttManager, dropList >	firstDrop;
	
	typedef uint32	KeyType;
	
	static const uint32 Version = 3927182119;
	
	uint32 Key() const;
	
	uint32 id() const;
	const char* name() const;
	uint8 fight_type() const;
	uint16 level() const;
	uint16 model_id() const;
	const skillid& skill_id() const;
	uint32 view_distance() const;
	uint8 monter_type() const;
	uint16 hpseg() const;
	const firstDrop& first_drops() const;
	uint8 pickrange() const;
	uint8 canquickpick() const;
	uint16 angrytime() const;
	
private:
	uint32    m_id;
	int       m_name;
	uint8     m_fight_type;
	uint16    m_level;
	uint16    m_model_id;
	skillid   m_skill_id;
	uint32    m_view_distance;
	uint8     m_monter_type;
	uint16    m_hpSeg;
	firstDrop m_first_Drops;
	uint8     m_pickRange;
	uint8     m_canQuickPick;
	uint16    m_angryTime;
};
#pragma pack()

// -------------------------------------------------------------------
// source: G 怪物配置.xls, sheet: Sheet1
class MonsterAttManager : public Table::Manager, public Singleton< MonsterAttManager >
{
public:
	int Size() const;
	const char* Source() const;
	bool Load( const char *path );
	bool Reload( const char *path );
	
	const MonsterAtt& Get( int index ) const;
	const MonsterAtt* Find( const uint32 key ) const;
	
private:
	friend class Singleton< MonsterAttManager >;
	typedef Table::RepeatField< MonsterAttManager, MonsterAtt >	MonsterAttArray;
	
	MonsterAttManager();
	~MonsterAttManager();
	
private:
	const MonsterAttArray *m_array;
};


// ===================================================================
// inline methords of MonsterAtt
inline uint32 MonsterAtt::Key() const
{
	return Combiner< uint32 >::Combine( m_id );
}

inline uint32 MonsterAtt::id() const
{
	return m_id;
}

inline const char* MonsterAtt::name() const
{
	return MonsterAttManager::Instance().String( m_name );
}

inline uint8 MonsterAtt::fight_type() const
{
	return m_fight_type;
}

inline uint16 MonsterAtt::level() const
{
	return m_level;
}

inline uint16 MonsterAtt::model_id() const
{
	return m_model_id;
}

inline const MonsterAtt::skillid& MonsterAtt::skill_id() const
{
	return m_skill_id;
}

inline uint32 MonsterAtt::view_distance() const
{
	return m_view_distance;
}

inline uint8 MonsterAtt::monter_type() const
{
	return m_monter_type;
}

inline uint16 MonsterAtt::hpseg() const
{
	return m_hpSeg;
}

inline const MonsterAtt::firstDrop& MonsterAtt::first_drops() const
{
	return m_first_Drops;
}

inline uint8 MonsterAtt::pickrange() const
{
	return m_pickRange;
}

inline uint8 MonsterAtt::canquickpick() const
{
	return m_canQuickPick;
}

inline uint16 MonsterAtt::angrytime() const
{
	return m_angryTime;
}


// inline methords of MonsterAtt::dropList
inline uint32 MonsterAtt::dropList::dropid() const
{
	return m_dropid;
}

inline uint32 MonsterAtt::dropList::dropnum() const
{
	return m_dropNum;
}


// inline methords of MonsterAttManager
inline MonsterAttManager::MonsterAttManager()
	: m_array( NULL )
{
}

inline MonsterAttManager::~MonsterAttManager()
{
}

inline int MonsterAttManager::Size() const
{
	assert( m_array );
	return m_array->Size();
}

inline const char* MonsterAttManager::Source() const
{
	return "monster_att.tbl";
}

inline bool MonsterAttManager::Load( const char *path )
{
	const char *data = Table::Manager::Load( path, Source() );
	if( !data )
		return false;
		
	m_array = (const MonsterAttArray *)data;
	return true;
}

inline bool MonsterAttManager::Reload( const char *path )
{
	const char *data = Table::Manager::Reload( path, Source() );
	if( !data )
		return false;
		
	m_array = (const MonsterAttArray *)data;
	return true;
}

inline const MonsterAtt& MonsterAttManager::Get( int index ) const
{
	assert( m_array );
	return m_array->Get( index );
}

inline const MonsterAtt* MonsterAttManager::Find( uint32 key ) const
{
	assert( m_array );
	return BinarySerach< MonsterAtt >( Data( m_array->Offset() ), m_array->Size(), key );
}


#endif
